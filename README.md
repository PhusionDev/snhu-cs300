## Project 1 submission file: CS300-Hodgkins_J-BigO.docx

## Project 2 submission file(s): [CMakeLists.txt, courses.csv, CS300-Hodgkins_J-Project2, src/]

Application can be built with CMake
Packaged executable was built on an Intel (x86_64) Macbook Pro running Monterey 12.5

### What was the problem you were solving in the projects for this course?

In this course I was tasked with exploring various data structures and algorithms used in Computer Science. The main ideas were that of solving problems and finding the most efficient ways to do so in different situations. I learned about different sorting algorithms and how each of them could be coded, how they worked, and how well or fast they performed with data sets. I learned about different structures for holding and accessing data such as arrays, vectors, linked lists, hash tables, and binary search trees. I learned about resursive functions that call themselves to aggregate a result, which I was able to implement extensively when designing a binary search tree. All of these things learned were so that I could effectively analyze which data structures and algorithms might best be suited for loading a csv containing a college's list of courses, storing that information, and then sorting and displaying those courses in alphanumeric order.

### How did you approach the problem? Consider why data structures are important to understand.

I approached the problem by looking at each of the data structures and algorithms and evaluating their performance in regards to basic operations speed such as creation/insert, searching/access, sorting, and printing. Memory usage can also play a part in the analysis of data structures and algorithms, but for this project it was on such a small scale with virtually unlimited resources that memory contraints were not taken into great consideration. However it's always important to understand the data that your application will be working with, such as the size and volume, and additionally the hardware in which the application will run on to make sure that it will run effectively without running out of resources.

### How did you overcome any roadblocks you encountered while going through the activities or project?

I used a few main resources when encountering roadblocks. My first instinct is always to try and debug the problem myself by adding a breakpoint where the troublesome code is, or adding extra console logs to see which branches the application is making it to or not making it to. I also found a lot of useful examples and references to the algorithms and data structures from the zybooks material for the course. Reading and re-reading the material helped to solidify concepts in many cases. For the times that I needed a little bit of extra understanding I would perform a search in google for the specific issue and then browse through 3-6 posts on the topic, making sure to read through the accepted answers and also a lot of additional feedback from other users as well. Whenever I'm getting help from sites such as stack overflow I always make sure to digest as much information on the page as possible and then go back to my own work and try to implement the things that made the most sense rather than simply copying and pasting the accepted answer.

### How has your work on this project expanded your approach to designing software and developing programs?

Prior to this course I knew about and was using hash maps/dictionaries, but I never knew how they worked under the hood or how to implement them. Additionally, most of my programming experience is in languages such as Python, JavaScript, and C# so I never really learned about or used linked lists before. Binary search trees were something I had only heard about and knew only a surface amount about, so learning how to create all these structures is a skill that I feel really helped me to understand how and why they are used. The sorting algorithms section was also very useful because I never knew how to implement quick sort or radix sort, etc, and simply relied on the implementations that the language(s) provided. After this course I feel that I am more curious to implement and discover different algorithms to solve various problems in Computer Science, and that my general skill set has improved for have taken it.

### How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

For the final project I made sure to break my source code up into separate files so that it was easy for me to design and maintain. For some of the earlier assignments in the course everything was all in one source code file, mainly for the convenience of turning in them into the professor to be graded, but I would much rather have things in their own place. This helps me to keep track of where I need to update certain lines of code, and it also helps with compile time as well: having the application broken up into self-contained chunks means that the entire code-base doesn't need to get recompiled every time that there's an independent change somewhere else. Commenting lines of code and adding function descriptions is a skill that I've improved on during my stay at SNHU as well. In my hobby projects I am usually coding as much as I can without worrying about commenting the code, but I've fallen victim to returning to my code months or years later and having a hard time remembering how things worked or what certain lines of code were doing, so needless to say I've learned that the hard way, but it's something that I feel more confident in now as I have made sure to comment frequently.
